using backend;
using backend.Data;
using backend.Data.Identity;
using backend.Infrastructure;
using Microsoft.AspNetCore.Authentication.BearerToken;
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.Data;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.OpenApi.Models;

var builder = WebApplication.CreateBuilder(args);

// TODO: Configure connection string and database provider
builder.Services.AddDbContext<PlatformContext>(options =>
{
	// TODO: Add the ability to use other providers
	options.UseSqlServer(builder.Configuration["ConnectionStrings:PlatformConnection"]);

	if (builder.Environment.IsDevelopment())
	{
		options.EnableSensitiveDataLogging(true);
	}
});

builder.Services
	.AddAuthentication(IdentityConstants.ApplicationScheme)
	.AddIdentityCookies();

builder.Services.AddAuthorizationBuilder();

/*
 * AddIdentity adds everything AddIdentityCore adds, with some extra services,
 * namely Cookie Schemes (Application, External, and 2FA Schemes are all registered),
 * SignInManager, and RoleManager. Note that AddIdentity adds Role services
 * automatically, unlike AddDefaultIdentity.
 */
builder.Services
	.AddIdentityCore<User>()
	.AddEntityFrameworkStores<PlatformContext>()
	.AddApiEndpoints();

// TODO: Add Localization

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(opts =>
{
	// TODO: Does the API support Non Nullable Reference types?

	// From Microsoft.OpenApi.Models
	var securityScheme = new OpenApiSecurityScheme
	{
		Name = "JWT Authentication",
		Description = "Enter your JWT token in this field",
		// REQUIRED. The location of the API key. Valid values are "query", "header" or "cookie".
		In = ParameterLocation.Header,
		// REQUIRED. The type of the security scheme. Valid values are "apiKey", "http", "oauth2", "openIdConnect".
		Type = SecuritySchemeType.Http,
		// REQUIRED. The name of the HTTP Authorization scheme to be used in the Authorization header as defined in RFC7235.
		Scheme = "bearer",
		// A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually generated by an authorization server, so this information is primarily for documentation purposes.
		BearerFormat = "JWT"
	};

	opts.AddSecurityDefinition("Bearer", securityScheme);

	var securityRequirement = new OpenApiSecurityRequirement
	{
		{
			new OpenApiSecurityScheme
			{
				Reference = new OpenApiReference
				{
					Type = ReferenceType.SecurityScheme,
					Id = "Bearer"
				}
			},
			new string[] {} // no specific scope is needed
		}
	};

	opts.AddSecurityRequirement(securityRequirement);

	opts.SwaggerDoc("v1", new OpenApiInfo { Title = "Publishing_Platform", Version = "v0.1" });
});

builder.Services.AddCors(
	options => options.AddPolicy(
		"wasm",
		policy => policy.WithOrigins([builder.Configuration["PlatformUrls:BackendUrl"] ?? "http://localhost:5120",
			builder.Configuration["PlatformUrls:BlazorWasmFrontendUrl"] ?? "http://localhost:5220"])
			.AllowAnyMethod()
			.AllowAnyHeader()
			.AllowCredentials()));

builder.Services.AddControllers();

/*
 * "You define the configuration using profiles. And then you let AutoMapper
 * know in what assemblies are those profiles defined by calling the IServiceCollection
 * extension method AddAutoMapper at startup"
 */
builder.Services.AddAutoMapper(cfg => { }, typeof(Program));

var app = builder.Build();

// TODO:EXPLAIN
app.MapIdentityApi<User>();
app.MapEmailLoginEndpoint();

// TODO:EXPLAIN
app.UseCors("wasm");

app.UseAuthentication();
app.UseAuthorization();

app.MapPost("/logout", async (SignInManager<User> signInManager, [FromBody] object empty) =>
{
	if (empty is not null)
	{
		await signInManager.SignOutAsync();

		return Results.Ok();
	}

	return Results.Unauthorized();
}).RequireAuthorization();

app.MapControllers();

if (app.Environment.IsDevelopment())
{
	app.UseSwagger();
	app.UseSwaggerUI(options => { options.SwaggerEndpoint("/swagger/v1/swagger.json", "Publishing_Platform"); });

	await using var scope = app.Services.CreateAsyncScope();
	await SeedData.PopulateDatabase(scope.ServiceProvider);
}

app.Run();